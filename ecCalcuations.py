#!/usr/bin/env python3

# with this script you can compute all the points of an elliptic curve and its order.
# you can also compute point addition or duplication
# with timing comparison you can compare the computing times between point duplication and addition
#
# on input it takes the modulus p, a and b of the curve
# python ellipticCurveGroupOperations p a b
#
# optionally you can input either one point for point duplication
# python ellipticCurveGroupOperations p a b x y
# or two points for point addition
# python ellipticCurveGroupOperations p a b x1 y1 x2 y2
#
#
# new goals for a more realistic approach
#   use a standardized elliptic curve and don't compute all points
#       takes way too long
#   get a curve and its generator and be able
#   to compute points with the generator in a
#   effective way
#
# source for standardized curves
# https://tools.ietf.org/html/rfc5639
# in this script brainpoolP160r1 is used
#   p is the prime specifying the base field.
#   A and B are the coefficients of the equation y ^ 2 = x ^ 3 + A*x + B
#   mod p defining the elliptic curve.
#   G = (x, y) is the base point, i.e., a point in E of prime order,
#   with x and y being its x - and y-coordinates, respectively.
#   q is the prime order of the group generated by G.
#   h is the cofactor of G in E, i.e.,  # E(GF(p))/q.
#
#       p = E95E4A5F737059DC60DFC7AD95B3D8139515620F_16
#           1332297598440044874827085558802491743757193798159_10

#       A = 340E7BE2A280EB74E2BE61BADA745D97E8F7C300_16
#           297190522446607939568481567949428902921613329152_10

#       B = 1E589A8595423412134FAA2DBDEC95C8D8675E58_16
#           173245649450172891208247283053495198538671808088_10

#       x = BED5AF16EA3F6A4F62938C4631EB5AF7BDBCDBC3_16
#           1089473557631435284577962539738532515920566082499_10

#       y = 1667CB477A1A8EC338F94741669C976316DA6321_16
#           127912481829969033206777085249718746721365418785_10

#       q = E95E4A5F737059DC60DF5991D45029409E60FC09_16
#           1332297598440044874827085038830181364212942568457_10

#       h = 1

import extendedEuclidian
import math


class ellipticCurve:

    # constructor -> sets parameters for the curve
    def __init__(self):

        p = 1332297598440044874827085558802491743757193798159   # mod of coordinates
        a = 297190522446607939568481567949428902921613329152    # a coefficient of the curve
        b = 173245649450172891208247283053495198538671808088    # b coefficient of the curve
        x = 1089473557631435284577962539738532515920566082499   # x of generator
        y = 127912481829969033206777085249718746721365418785    # y of generator
        q = 1332297598440044874827085038830181364212942568457   # order of generator

        calculateOrder()

    # function for calculating the order of the curvecurve
    def calculateOrder(self):
        points = []
        possibleYs = []

        # get all possible y values
        for x in range(0, p, 1):
            possibleYs.append((x*x) % p)

        # check if y values exist for current x
        for x in range(0, p, 1):
            fX = (x ** 3 + a * x + b) % p
            for i in range(len(possibleYs)):
                if possibleYs[i] == fX:
                    y = i

                    # if point exists, add it to the curves points
                    points.append((x, y))

        # set the order of the group after computing all the points
        order = len(points) + 1

    # getInfo prints out information about the curve in the terminal
    def getInfo(self):
        print(
            f"\nthe given elliptic curve\ny^2 = x^3 + {a}x + {b} mod {p} has these points:\n\n{points} and the point of infinity\n\nand an order of {len(points)}\n")

    # pointAddition takes a two Points and calculates the addition of those on instantiation
    def pointAddition(P, Q):
        gradient: int

        # check whether addition is possible
        if P == Q:
            print(
                "you can't do addition with the same point, you need to perform point duplication")
        else:
            isPointOfInfinity = False
            if P[0] == Q[0]:
                isPointOfInfinity = True
            else:

                # perform the addition
                divident = turnPositive(curve.p, Q[1]-P[1] % curve.p)
                diviser = Q[0]-P[0] % curve.p
                inverse = extendedEuclidian.getInverse(curve.p, diviser)
                gradient = divident*inverse % curve.p
                x = (gradient ** 2 - P[0] - Q[0]) % curve.p
                y = turnPositive(
                    curve.p, ((gradient*(P[0]-x)-P[1]) % curve.p))
            # print out the new point
            if isPointOfInfinity:
                print(f"\n{P} + {P} is the point of infinity!")
            else:
                print(f"\n{P} + {Q} is ({x}, {y})!")

    # pointDuplication takes the point it has to duplicate and computes the duplication on instantiation
    def pointDuplication(P):
        isPointOfInfinity = False
        if P[1] == 0:
            isPointOfInfinity = True
        else:
            gradient: int
            divident = (3*(P[0]**2) + curve.a) % curve.p
            diviser = 2 * P[1] % curve.p
            inverse = extendedEuclidian.getInverse(curve.p, diviser)
            gradient = divident*inverse % curve.p
            x = turnPositive(
                curve.p, (gradient ** 2 - P[0] - P[0]) % curve.p)
            y = turnPositive(
                curve.p, ((gradient*(P[0]-x)-P[1]) % curve.p))
        # print out the new point
        if isPointOfInfinity:
            print(f"\n{P} + {P} is the point of infinity!")
        else:
            print(f"\n{P} + {P} is ({x}, {y})!")

    def pointExists(x, y):
        givenPoint = (x, y)
        isPoint = False
        for point in curve.points:
            if givenPoint == point:
                isPoint = True
        return isPoint


def hasSinguarities(p, a, b):
    return True if (4*a**3+27*self.b**2) % p == 0 else False


def turnPositive(p, element):
    return p + element if element < 0 else element


class Point:

    def __init__(self, x, y):
        x = x
        y = y
